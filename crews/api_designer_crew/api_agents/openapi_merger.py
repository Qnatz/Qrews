from typing import Optional, Dict, Any, List
import copy # For deep copying objects to avoid modifying inputs

try:
    from .models import (
        OpenAPISpec, OpenAPIInfo, OpenAPIComponents,
        EndpointList, SchemaComponents, RequestResponseMap, AuthDefinition, ErrorSchemaDefinition,
        OpenAPIPathItem, OpenAPIOperation # For type hinting and potentially deeper merging
    )
    from utils.api_crew_utils import LoggerPlaceholder # CORRECTED
except ImportError as e_merger_import: # Capture the exception
    print(f"DEBUG: ImportError in openapi_merger.py: {e_merger_import}") # Print the captured exception
    # Fallback for direct execution or path issues
    # This is simplified; real testing would require proper path setup or mocking
    class MockBaseModel: # Basic mock for Pydantic models if not found
        def __init__(self, **kwargs):
            print("DEBUG: openapi_merger.py MockBaseModel __init__ called!")
            self.__dict__.update(kwargs)
        def model_dump_json(self, **kwargs): import json; return json.dumps(self.__dict__)
        def model_dump(self, **kwargs): return self.__dict__ # Add model_dump for Pydantic v2 compatibility in mocks

    OpenAPISpec, OpenAPIInfo, OpenAPIComponents = MockBaseModel, MockBaseModel, MockBaseModel
    EndpointList, SchemaComponents, RequestResponseMap = MockBaseModel, MockBaseModel, MockBaseModel
    AuthDefinition, ErrorSchemaDefinition = MockBaseModel, MockBaseModel
    OpenAPIPathItem, OpenAPIOperation = MockBaseModel, MockBaseModel

    class LoggerPlaceholder:
        def log(self, message: str, role: str = "Test", level: str = "INFO"):
            print(f"[{level}] [{role}] {message}")


class OpenAPIMerger:
    def __init__(self, logger: Optional[LoggerPlaceholder] = None):
        self.agent_name = "openapi_merger"
        self.logger = logger or LoggerPlaceholder()
        self.logger.log(f"{self.agent_name.capitalize()} initialized.", role=self.agent_name)

    def merge_openapi_parts(self,
                            project_name: str,
                            project_objective: str,
                            api_version: str = "1.0.0",
                            endpoint_list: Optional[EndpointList] = None, # For context/validation
                            schema_components: Optional[SchemaComponents] = None,
                            request_response_map: Optional[RequestResponseMap] = None,
                            auth_definition: Optional[AuthDefinition] = None,
                            error_definition: Optional[ErrorSchemaDefinition] = None
                           ) -> OpenAPISpec:
        """
        Merges various OpenAPI parts generated by different sub-agents into a single
        OpenAPISpec object.
        """
        self.logger.log(f"Starting OpenAPI merge for project: {project_name}", role=self.agent_name)

        # Initialize with Pydantic models if available, otherwise dicts for mocks
        info_data = {
            "title": f"{project_name} API",
            "version": api_version,
            "description": project_objective
        }
        components_data = {"schemas": {}}

        openapi_spec_data = {
            "openapi": "3.0.3",
            "info": OpenAPIInfo(**info_data) if OpenAPIInfo.__name__ != 'MockBaseModel' else info_data,
            "paths": {},
            "components": OpenAPIComponents(**components_data) if OpenAPIComponents.__name__ != 'MockBaseModel' else components_data
        }
        openapi_spec = OpenAPISpec(**openapi_spec_data)


        current_components = openapi_spec.components
        # Ensure components and schemas are dicts for updates, especially if using mocked models
        if not isinstance(current_components, dict) and hasattr(current_components, 'model_dump'): # Pydantic model
             current_components_dict = current_components.model_dump(exclude_none=True)
        elif isinstance(current_components, dict): # Already a dict (mock or direct init)
             current_components_dict = current_components
        else: # Should not happen with proper init
             current_components_dict = {"schemas": {}}

        if "schemas" not in current_components_dict:
            current_components_dict["schemas"] = {}

        def update_schemas(source_schemas_container, source_name_attr, container_name_for_log):
            if source_schemas_container and hasattr(source_schemas_container, source_name_attr):
                source_schemas = getattr(source_schemas_container, source_name_attr)
                if source_schemas:
                    count = 0
                    for name, schema_data in source_schemas.items():
                        if name in current_components_dict["schemas"]:
                            self.logger.log(f"Schema '{name}' from {container_name_for_log} conflicts. Overwriting.", level="WARNING", role=self.agent_name)
                        # Deepcopy the schema data (which could be a Pydantic model or a dict)
                        current_components_dict["schemas"][name] = copy.deepcopy(schema_data)
                        count +=1
                    self.logger.log(f"Merged {count} schemas from {container_name_for_log}.", role=self.agent_name)

        update_schemas(schema_components, 'schemas', "SchemaDesigner")
        update_schemas(error_definition, 'error_schemas', "ErrorDesigner")


        if request_response_map and hasattr(request_response_map, 'paths') and request_response_map.paths:
            # Deepcopy paths data (could be dict of PathItem models or dicts)
            openapi_spec.paths = copy.deepcopy(request_response_map.paths)
            self.logger.log(f"Added {len(request_response_map.paths)} paths from RequestResponseDesigner.", role=self.agent_name)

        if auth_definition:
            if hasattr(auth_definition, 'security_schemes') and auth_definition.security_schemes:
                if "securitySchemes" not in current_components_dict:
                    current_components_dict["securitySchemes"] = {}
                current_components_dict["securitySchemes"].update(copy.deepcopy(auth_definition.security_schemes))
                self.logger.log(f"Added/updated {len(auth_definition.security_schemes)} security schemes.", role=self.agent_name)

            if hasattr(auth_definition, 'global_security') and auth_definition.global_security:
                openapi_spec.security = copy.deepcopy(auth_definition.global_security)
                self.logger.log("Applied global security requirements.", role=self.agent_name)

        # Re-assign components if it was converted to dict for manipulation
        if OpenAPIComponents.__name__ != 'MockBaseModel':
            openapi_spec.components = OpenAPIComponents(**current_components_dict)
        else:
            openapi_spec.components = current_components_dict

        self.logger.log("OpenAPI merge completed.", role=self.agent_name)
        return openapi_spec

if __name__ == '__main__':
    logger = LoggerPlaceholder()
    logger.log("Testing OpenAPIMerger...")

    # Attempt to import real models for testing if possible
    RealOpenAPISchema = None # Define upfront for later checks
    try:
        from crews.api_designer_crew.api_agents.models import ( # CORRECTED
            OpenAPISpec as RealOpenAPISpec, OpenAPIInfo as RealOpenAPIInfo,
            OpenAPIComponents as RealOpenAPIComponents, EndpointList as RealEndpointList,
            SchemaComponents as RealSchemaComponents, RequestResponseMap as RealRequestResponseMap,
            AuthDefinition as RealAuthDefinition, ErrorSchemaDefinition as RealErrorSchemaDefinition,
            OpenAPIPathItem as RealOpenAPIPathItem, OpenAPIOperation as RealOpenAPIOperation,
            OpenAPISchema as ImportedRealOpenAPISchema # For constructing mock schemas
        )
        # Use real models if import successful
        OpenAPISpec, OpenAPIInfo, OpenAPIComponents = RealOpenAPISpec, RealOpenAPIInfo, RealOpenAPIComponents
        EndpointList, SchemaComponents, RequestResponseMap = RealEndpointList, RealSchemaComponents, RealRequestResponseMap
        AuthDefinition, ErrorSchemaDefinition = RealAuthDefinition, RealErrorSchemaDefinition
        OpenAPIPathItem, OpenAPIOperation = RealOpenAPIPathItem, RealOpenAPIOperation
        RealOpenAPISchema = ImportedRealOpenAPISchema # Assign to the broader scope variable
        logger.log("Using real Pydantic models for OpenAPIMerger test.", role="TestSetup")
    except ImportError:
        logger.log("Real Pydantic models not found for OpenAPIMerger test. Using basic mocks.", level="WARNING", role="TestSetup")
        # Basic mocks are defined at the top level of the string for this case

    merger = OpenAPIMerger(logger=logger)

    mock_project_name = "Test Merged API"
    mock_project_objective = "To test the merging of OpenAPI components."

    # Mock data construction needs to be compatible with Pydantic or dicts
    mock_ep_list_data = {"endpoints":[
        {"method": "get", "path": "/items", "description": "List items", "operationId": "listItems"}
    ]}
    mock_ep_list = EndpointList(**mock_ep_list_data) if EndpointList.__name__ != 'MockBaseModel' else mock_ep_list_data


    item_schema_def = {"type": "object", "properties": {"id": {"type": "string"}, "name": {"type": "string"}}}
    user_schema_def = {"type": "object", "properties": {"userId": {"type": "integer"}, "username": {"type": "string"}}}
    notfound_schema_def = {"type": "object", "properties": {"error": {"type": "string"}, "message": {"type": "string"}}}

    mock_schemas_data_dict = {
        "Item": RealOpenAPISchema(**item_schema_def) if RealOpenAPISchema else item_schema_def,
        "User": RealOpenAPISchema(**user_schema_def) if RealOpenAPISchema else user_schema_def
    }
    mock_schemas = SchemaComponents(schemas=mock_schemas_data_dict) if SchemaComponents.__name__ != 'MockBaseModel' else {"schemas": mock_schemas_data_dict}

    mock_paths_op_item_data = {
        "summary":"Get all items",
        "responses":{"200": {"description": "A list of items", "content": {"application/json": {"schema": {"type": "array", "items": {"$ref": "#/components/schemas/Item"}}}}}}
    }
    mock_paths_op_item = OpenAPIOperation(**mock_paths_op_item_data) if OpenAPIOperation.__name__ != 'MockBaseModel' else mock_paths_op_item_data

    mock_req_resp_map_data = {"paths": {
        "/items": OpenAPIPathItem(get=mock_paths_op_item) if OpenAPIPathItem.__name__ != 'MockBaseModel' else {"get": mock_paths_op_item}
    }}
    mock_req_resp_map = RequestResponseMap(**mock_req_resp_map_data) if RequestResponseMap.__name__ != 'MockBaseModel' else mock_req_resp_map_data

    mock_auth_def_data = {
        "security_schemes":{
            "ApiKeyAuth": {"type": "apiKey", "in": "header", "name": "X-API-KEY"}
        },
        "global_security":[{"ApiKeyAuth": []}]
    }
    mock_auth_def = AuthDefinition(**mock_auth_def_data) if AuthDefinition.__name__ != 'MockBaseModel' else mock_auth_def_data

    mock_error_schemas_data_dict = {
        "NotFoundError": RealOpenAPISchema(**notfound_schema_def) if RealOpenAPISchema else notfound_schema_def
    }
    mock_error_def_data = {
        "error_schemas":mock_error_schemas_data_dict,
        "error_responses_references":{
            "404": {"$ref": "#/components/schemas/NotFoundError"}
        }
    }
    mock_error_def = ErrorSchemaDefinition(**mock_error_def_data) if ErrorSchemaDefinition.__name__ != 'MockBaseModel' else mock_error_def_data


    merged_spec = merger.merge_openapi_parts(
        project_name=mock_project_name,
        project_objective=mock_project_objective,
        schema_components=mock_schemas,
        request_response_map=mock_req_resp_map,
        auth_definition=mock_auth_def,
        error_definition=mock_error_def
    )

    if merged_spec:
        logger.log("OpenAPIMerger test successful.")
        # Access attributes based on whether they are Pydantic models or dicts
        info_title = merged_spec.info.title if hasattr(merged_spec.info, 'title') else merged_spec.info['title']
        paths_dict = merged_spec.paths if isinstance(merged_spec.paths, dict) else merged_spec.paths.model_dump()
        components_dict = merged_spec.components if isinstance(merged_spec.components, dict) else merged_spec.components.model_dump()

        assert info_title == f"{mock_project_name} API"
        assert "/items" in paths_dict
        assert "Item" in components_dict.get("schemas", {})
        assert "User" in components_dict.get("schemas", {})
        assert "NotFoundError" in components_dict.get("schemas", {})
        assert "ApiKeyAuth" in components_dict.get("securitySchemes", {})
        assert merged_spec.security is not None or merged_spec.get("security") is not None

        logger.log(f"Merged Spec (summary): Info title: {info_title}, Paths count: {len(paths_dict)}, Schemas count: {len(components_dict.get('schemas', {}))}")
    else:
        logger.log("OpenAPIMerger test failed.")
